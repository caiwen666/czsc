# 五 取模运算与空间限制

我们经常在题目中看到一道题目有两个限制：空间限制和时间限制，有时候我们也把他们并称为时空限制。我们这节就先来讨论一下空间限制。同时，我们还介绍一下算法竞赛中常见的一个东西：取模运算。

## 1 取模运算

取模运算，这算是算法竞赛中比较重要的一个内容。而具体介绍取模运算之前还需要介绍一些其他的知识。

### 1.1 数学符号

我们在这里简单科普一些数学符号。

首先是一些取整符号，我们在之前应该就见过，这里再见一遍：

* $\left \lfloor x \right \rfloor $ ：向下取整
* $\left \lceil x \right \rceil $ ：向上取整
* $\left [ x \right ] $ ：向下取整

然后是求和符号，对于求和符号我们可以在脑海中将其和 for 循环联系起来，方便理解：

* $\sum_{i=1}^{n} i$ ：$i$ 从 $1$ 开始增长到 $n$ ，然后都给加起来
* $\sum_{i=l}^{r} i^3$ ：$i$ 从 $l$ 开始增长到 $r$ ，然后把三次方都给加起来
* $\sum_{i=l}^{r} 2i+3 $ ：相当于 $(2l+3) + (2(l+1)+3) + (2(l+2)+3)+...+(2(r-1)+3)+(2r+3)$

然后是累乘符号，和上面的求和符号类似，只不过加法改成乘法：

* $\prod_{i=1}^{n}i$ ：相加改为相乘

### 1.2 科学计数法

在 C++ 中我们也用这样的方式表示科学计数法：
$1e9=10^9$ , $2e10=2\times 10^9$。这是可以直接写在代码里的，比如 `int p=1e9+7;`，`p` 的值就是 $1\times 10^9 + 7$。

有的地方可能写 `10^9` 表示 $10^9$，这里的 `^` 就是表示后面数字应该是一个上角标。这种写法并不是非常正式的写法，你看到这样的表示应该知道是什么意思，但是代码里千万不要这么写，也就是不要写成 `int a=10^9;`，这样并非表示 $10^9$！而是应该写成 `int a=1e9;`

### 1.3 数据类型的范围

事实上，C++ 里表示整数的数据类型并非只有 int 类型，还有一个 long long 类型。他俩的用法完全一致，但是不同点在于他们能够表示的数字范围不同。

对于 int 类型，他其实并不能表示任意大小的数字，他最大能够表示的数字为 $2^31 - 1$，最小能够表示的数字为 $-2^31$，超出这个范围为更大或者更小的数字 int 类型无法表示，执意使用 int 类型会发生意想不到的错误。

对于 long long 类型，他能够表示的数字范围大一点，他最大能够表示的数字为 $2^63-1$，最小能够表示的数字为 $-2^63$。

无论是 int 还是 long long 都不能表示任意大的数字。如果你的程序需要处理的数字超过了 long long 的范围，那么就需要想别的办法了，也会变得更加麻烦了。

C++ 代码中直接写出来的数字都是 int 类型字面量。如果我们说明一个数字实际上是一个 long long 类型的字面量，那么我们可以在这个数字后面加 `ll`。比如 `long long num=114514ll;`。

值得一提的是，int 和 long long 之间也有类似我们之前所讨论的 int 和 double 之间的关系：即如果 long long 发生了到 int 的数据类型转换，那么就可能发生精度损失（long long 类型表示的超过 int 类型范围的数字就不能用 int 类型正常表示了）；如果 long long 和 int 类型混合运算，运算结果为 long long 类型（因为 long long 的精度高）；以及我们可以考虑使用显示强制数据类型转换，或是在算式的最开头乘上 `1ll` 来提高算式运算的精度。这些都是第一节课就讨论过的类似的东西。

### 1.4 取模的性质

由于某些题目的计算结果可能超出了 long long 的数据范围，题目为了方便，就要求你将结果对某个数字取模之后，把得到的余数给输出出来。

显然，如果我们把计算结果算出来然后再取模，那么就失去了取模的意义了，毕竟你都能把结果算出来，那为什么不直接输出呢。为了让运算过程中出现的所有数字都在 long long 范围内，且最后还能得到最终结果对给定数字取模的余数，我们需要熟练使用如下的取模性质：

* $(a+b)\%p=(a\%p+b\%p)\%p$ 
* $(a*b)\%p=a\%p*b\%p$
* $(a-b)\%p=(a\%p-b\%p+p)\%p$

有什么用？我们拿第一个加法的举例。有可能 a 和 b 都是一个很大的数字，两者相加就超出 long long 范围了，我们就无法直接算出 $a+b$ 对 p 取模的结果。而借助取模的性质，我们可以先让 a 和 b 分别对 p 取模，然后再相加再对 p 取模，这样就不会超出 long long 范围了。因为一般题目给出的模数 p 不会特别大（接近 long long 返回边界那种），一般都可以保证两个 p 相加或是相乘都不会超出 long long 范围。而我们之前就了解过，一个数对 p 取模之后得到的结果是必然不会大于 p。因此，我们反复对 p 取模，感性上来讲是希望运算过程中的所有的数字都在 $[0,p-1]$ 这个范围内，而取模的性质就为这个想法提供数学依据。

值得注意的是最后一个减法的，需要先加上一个 p 再对 p 取模。

加减乘都有取模性质，那么除法呢？很抱歉没有类似上述的性质，如果想做到类似的效果的话，需要使用乘法逆元，这个东西属于算法竞赛中数论部分的内容，我们会在后面学习。

## 2 内存占用

我们的电脑或是手机，一般都有内存空间和存储空间。比如我们要买手机就经常会说“16+512”之类的，一般这个较小的数字就是内存大小，较大的数字就是存储大小。我们的程序在运行过程中会占用一定的内存空间。具体来说，我们的程序在运行过程中声明的所有变量就占了一定的内存。如果只是一个普通的变量，一般占不了多大的内存，或者说占的内存忽略不计。如果变量是一个数组，且数组大小特别大的话，占用的内存大小就非常明显。题目上写的“空间限制”实际上就指明了你这个程序最大能够使用多少内存。因此如果我们开很大的数组的话，很容易导致占用过多的内存导致程序超出空间限制（MLE）。

为了防止 MLE，我们最好提前计算一下我们开的变量总共占了多少的内存空间。C++ 中自带一个叫做 `sizeof` 的函数可以获得变量占用内存空间，单位为字节（用 b 来表示）。1024b = 1kb（千字节），1024kb = 1mb（兆字节）。由于题目给的空间限制的单位多是 mb，因此我们经常把 `sizeof` 的结果除两个 1024 再输出，这样输出的单位就是 mb。

如：

```cpp
#include<bits/stdc++.h>
using namespace std;

int a1[10000007];
int a2[100000008];
long long b1[10000007];
long long b2[100000008];

int main(){
	cout<<sizeof(a1)/1024/1024<<endl;
	cout<<sizeof(a2)/1024/1024<<endl;
	cout<<sizeof(b1)/1024/1024<<endl;
	cout<<sizeof(b2)/1024/1024<<endl; 
	return 0;
} 
```

输出结果为

```
38
381
76
762
```

于是我们发现，对于 int 类型，数组长度到 1e7 的级别才会占用 38mb，如果我们程序中没有这么大的数组应该是不用担心 MLE 的，也就是我们大概只需要对代码中出现的长度到 1e7 这个级别的数组使用 sizeof 进行检查，其他的数组或者普通变量没必要。

同时我们还发现，1e8 长度的 int 数组就占了 381mb 了，而一般题目的内存限制都为 128mb、256mb 或是 512mb，也就意味着我们的程序基本开不了 1e8 大小的数组，或是撑死了只能有一个。

然后我们还发现，数据类型不同，占用的内存大小也不同。由于 long long 能表示的范围更大，所以理应占用更多的内存，而一般 long long 占用的内存是 int 的两倍。

## 3 题目选讲

**【例5.1】狄利克雷卷积** https://hydro.ac/d/czsc/p/P1022

这道题目涉及的东西比较多，我们搞明白这个题目能学到很多。

首先分析一下题目，先不管取模，题目让我们求 $F(n)$，而 $F(n)$ 依赖于 $f_i$ 和 $x^i$。$x^i$ 相对来说比较好搞，我们看 $f_i$。$f_i$ 依赖于 $f_{i-1}$ 和 $f_{i-2}$。而 $f_{i-1}$ 同理又依赖于 $f_{i-2}$ 和 $f_{i-3}$...这么一直依赖下去，直到有个头：$f_0=0$，$f_1=1$（实际上我们称这种不断向前依赖的关系叫做递推关系，最后的这个“头”叫做递推边界。我们可以从递推边界开始，由 $f_0$ 和 $f_1$ 得到 $f_2$，再由 $f_1$ 和 $f_2$ 得到 $f_3$，就能这么不断地推导下去...所以叫递推）。实际上，$x^i$ 也是一个递推关系，因为 $x^i=x^{i-1}\times x$。我们直到 $x^0=1$，从这个递推边界开始，所有的 $x^i$ 都能由前一个乘上 $x$ 获得。我们可以开循环，从递推边界开始逐个向后推导，推出来的结果用数组保存下来：

```cpp linenums="1"
#include<bits/stdc++.h>
using namespace std;
int f[10000007],xi[10000007];
int main(){
	int n,a,b,x;
	cin>>n>>a>>b>>x;
    // 递推 f_i
	f[0]=0;
	f[1]=1;
	for(int i=2;i<=n;i++){
		f[i]=a*f[i-1]+b*f[i-2];
	}
    // 递推 x^i
	xi[1]=x;
	for(int i=2;i<=n;i++){
		xi[i]=xi[i-1]*x;
	}
    // 求 F(n)，是一个求和式，我们开循环即可
	int ans=0;
	for(int i=1;i<=n;i++){
		ans=ans+f[i]*xi[i];
	}
	cout<<ans;
	return 0;
} 
```

等一下，题目让我们取模，我们忘取模了，别忘了加上去：

```cpp linenums="23"
	cout<<ans%(1e9+9);
```

跑一下这个代码，Dev-C++ 竟然报错了，怎么回事？忘了说了，`1e9+9` 这种 C++ 中的科学计数法表示的字面量的类型是 double 类型，而 `%` 取模操作只是针对于整数而言的，对于浮点数不存在这个取模操作，所以报错了。解决办法也很简单，我们可以用一个强制数据类型转换，强制把 `1e9+9` 变成 int 类型。

```cpp linenums="23"
	cout<<ans%(int)(1e9+9);
```

样例轻松通过，提交之后竟然获得 0 分，出了什么问题？这也是初学者经常犯得错误：题目让取模我就只在最后输出答案那里取模了。我们还是回顾一下为什么要取模，是因为结果可能会很大，long long 都存不下，利用取模的性质可以让运算过程中的数字都保持在一个较小的范围（即模数的范围）。我们运算过程需要用到取模的性质。

由于我们可能会多次用到这个模数，所以不妨将其定义为一个变量。

```cpp linenums="1" hl_lines="4 12 17 22 24"
#include<bits/stdc++.h>
using namespace std;
int f[10000007],xi[10000007];
int mod=1e9+9; // 注意这里其实有个隐式数据类型转换
int main(){
	int n,a,b,x;
	cin>>n>>a>>b>>x;
    // 递推 f_i
	f[0]=0;
	f[1]=1;
	for(int i=2;i<=n;i++){
		f[i]=(a*f[i-1]+b*f[i-2])%mod;
	}
    // 递推 x^i
	xi[1]=x;
	for(int i=2;i<=n;i++){
		xi[i]=xi[i-1]*x%mod;
	}
    // 求 F(n)，是一个求和式，我们开循环即可
	int ans=0;
	for(int i=1;i<=n;i++){
		ans=ans+f[i]*xi[i]%mod;
	}
	cout<<ans%mod;
	return 0;
} 
```

提交之后还是 0 分！？实际上，对于需要取模的题目，往往计算中间涉及到的数字很大，我们建议是一律使用 long long 类型，以防中间结果可能超出 int 类型的范围。一个一个把 int 改成 long long 不太方便，我们可以在开头加一个 `#define int long long`，然后把 `int main` 改成 `signed main`。这个操作就是让 C++ 自动帮我们把所有的 int 替换为 long long。但是我们说 main 函数规定返回值必须是 int 类型，这么操作之后 main 函数返回值类型就变成 long long 了，就会报错。为了解决这个问题，我们使用 `signed main`，`signed` 实际上是 `int` 的一个别名。

```cpp linenums="1" hl_lines="2 6"
#include<bits/stdc++.h>
#define int long long
using namespace std;
int f[10000007],xi[10000007];
int mod=1e9+9; // 注意这里其实有个隐式数据类型转换
signed main(){
	int n,a,b,x;
	cin>>n>>a>>b>>x;
    // 递推 f_i
	f[0]=0;
	f[1]=1;
	for(int i=2;i<=n;i++){
		f[i]=(a*f[i-1]+b*f[i-2])%mod;
	}
    // 递推 x^i
	xi[1]=x;
	for(int i=2;i<=n;i++){
		xi[i]=xi[i-1]*x%mod;
	}
    // 求 F(n)，是一个求和式，我们开循环即可
	int ans=0;
	for(int i=1;i<=n;i++){
		ans=ans+f[i]*xi[i]%mod;
	}
	cout<<ans%mod;
	return 0;
} 
```

好，这次就通过了很多测试点了，但是仍然有几个测试点 MLE 了。不过再解决 MLE 之前我必须指出上述代码还存在的重大漏洞，这也是初学者经常会犯得：运用取模的性质时，我们最好是每进行一次加减乘运算就取一次模，来时刻维持住运算结果在一个小的范围内。上述代码中，很多地方我们其实是少取模了，比如 `f[i]=(a*f[i-1]+b*f[i-2])%mod;` 中，我们相当于只对这个加法运算结果取模了，而在加法之前，还有两个乘法，这两个乘法的运算结果没取模。试想一下，有可能两数相乘的运算结果很大，然后两个很大的结果相加，还没来得及取模就超出 long long 范围了。我们目前还能通过这么多的测试点，是题目的数据太“水”。我们需要非常重视这个问题，因为将来某一天你可能因为某个非常细小的地方少取了模，而导致整道题从 100 分变为 0 分！改动之后代码如下：

```cpp linenums="1" hl_lines="13 23"
#include<bits/stdc++.h>
#define int long long
using namespace std;
int f[10000007],xi[10000007];
int mod=1e9+9; // 注意这里其实有个隐式数据类型转换
signed main(){
	int n,a,b,x;
	cin>>n>>a>>b>>x;
    // 递推 f_i
	f[0]=0;
	f[1]=1;
	for(int i=2;i<=n;i++){
		f[i]=(a*f[i-1]%mod+b*f[i-2]%mod)%mod;
	}
    // 递推 x^i
	xi[1]=x;
	for(int i=2;i<=n;i++){
		xi[i]=xi[i-1]*x%mod;
	}
    // 求 F(n)，是一个求和式，我们开循环即可
	int ans=0;
	for(int i=1;i<=n;i++){
		ans=(ans+f[i]*xi[i]%mod)%mod;
	}
	cout<<ans%mod;
	return 0;
} 
```

然后我们考虑如何解决 MLE 这个问题。由于我们的代码中出现了很大的数组（量级达到了 1e7），我们赶紧输出一下 sizeof 的结果，由于 `f` 和 `xi` 差不多，所以我们只输出一个就可以：

```cpp linenums="1" hl_lines="7"
#include<bits/stdc++.h>
#define int long long
using namespace std;
int f[10000007],xi[10000007];
int mod=1e9+9; // 注意这里其实有个隐式数据类型转换
signed main(){
    cout<<sizeof(f)/1024/1024;
	int n,a,b,x;
	cin>>n>>a>>b>>x;
    // 递推 f_i
	f[0]=0;
	f[1]=1;
	for(int i=2;i<=n;i++){
		f[i]=(a*f[i-1]%mod+b*f[i-2]%mod)%mod;
	}
    // 递推 x^i
	xi[1]=x;
	for(int i=2;i<=n;i++){
		xi[i]=xi[i-1]*x%mod;
	}
    // 求 F(n)，是一个求和式，我们开循环即可
	int ans=0;
	for(int i=1;i<=n;i++){
		ans=(ans+f[i]*xi[i]%mod)%mod;
	}
	cout<<ans%mod;
	return 0;
} 
```

输出结果为 `76`，那么就相当于 `f` 和 `xi` 这两个总共就占了 152mb 的内存，而题目数据上写明，最后几个测试点限制内存为 128mb 甚至 64mb。所以我们现在需要考虑如何尽可能节省空间。

一般考虑节省空间，我们需要考虑一些大数组是不是并没有必要。这道题中我们发现：`xi` 和 `f` 在递推的时候，其实只依赖于前一项或是前两项，所以我们并不需要开一个数组把所有的项都存储起来。有人可能觉得，我们最后计算总体答案的时候还是需要知道所有的项。但其实，我们可以把所有计算过程都合并到一个循环中，先计算新的 `xi` 和 `f`，然后 `ans` 基于新的 `xi` 和 `f` 更新。

```cpp linenums="1"
#include<bits/stdc++.h>
#define int long long
using namespace std;
int mod=1e9+9;
signed main(){
	int n,a,b,x;
	cin>>n>>a>>b>>x;
	int f0=0,f1=1; // f0 相当于 f[i-2]，f1 相当于 f[i-1] 
	int ans=x; // 最开始是 f[1]*xi[1]，也就是 x 
	int lasx=x; // lasx 相当于 xi[i-1]。下面的循环从 i=2 开始， lasx 初始值为 x 
	for(int i=2;i<=n;i++){ // i=1已经从上面算过了，这里i从2开始 
		int fi=(a*f1%mod+b*f0%mod)%mod; // 新的 f
		int xi=lasx*x%mod;
		ans=(ans+fi*xi%mod)%mod;
		// 即将进入下一层循环，把当前项变成上一项
		f0=f1,f1=fi;
		lasx=xi; 
	}
	cout<<ans%mod;
	return 0;
} 
```

这样一来，我们通篇代码都没有数组，只有几个变量，内存占用非常小。于是我们终于通过本题。

## 4 总结

* 数学符号补充
* 科学计数法
* 取模性质
	* 数据类型范围，long long
	* 进行一次运算后立即进行取模
* 数据类型内存占用
	* 数据类型占用内存
	* 递推，节省空间

## 5 作业

请再次独立做一遍本节题目选讲部分的题目：

* **【例5.1】狄利克雷卷积** https://hydro.ac/d/czsc/p/P1022

作业题目：

* **【作业5.1】没有用的前缀和** https://hydro.ac/d/czsc/p/P1011
* **【作业5.2】杨辉三角** https://hydro.ac/d/czsc/p/P1012
* **【作业5.3】第二类斯特林数** https://hydro.ac/d/czsc/p/P1013