# 六 前缀和与差分算法

上节课我们提到了算法竞赛中的两个限制：空间限制和时间限制，并在上节课简要介绍了一下空间限制以及 MLE（超出空间限制）之后的解决方案。从这里开始，我们开始关注另一个限制：时间限制。相比于空间限制，时间限制更加难以解决。为了解决时间限制，让程序运行的更快，我们需要利用各种数据结构和算法。本节课我们就来学习两个算法：前缀和算法和差分算法。

## 1 等差数列求和

在正式开始之前我们还是要先讲点数学：

考虑一个问题，从 $1$ 加到 $n$ 得多少？诚然我们能够写一个 C++ 代码，开循环求解。但是我们能不能直接有一个数学公式，只需要把 $n$ 带入这个公式计算就得到答案？事实上数学家高斯在很小的时候就发现了该公式。我们大概讲一下，高斯首先把 $1$ 到 $n$ 正着写了一遍，又倒着写了一遍，大概如下：

$$
\begin{aligned}
&1&,&2&,&3&, &... &,&n-2&,&n-1&,&n \\
&n&,&n-1&,&n-2&, &... &,&3&,&2&,&1
\end{aligned}
$$

然后他发现一个事，这两行数，上下相加都等于 $n+1$。然后上下一共能凑 $n$ 个 $n+1$，那么上下这 $2n$ 个数字加起来就等于 $n(n+1)$，然后这个就相当于从 $1$ 到 $n$ 加和的两倍，再除以一个 $2$ 就得到从 $1$ 加到 $n$ 的公式了：

$$
\sum_{i=1}^n i=\frac{n(n+1)}{2}
$$

然后我们变一下，现在不是从 $1$ 加到 $n$ 了，而是从 $2$ 或者 $3$，甚至从 $k(k<n)$ 加到 $n$，那么我们怎么办？我们可以先从 $1$ 加到 $n$，然后再减去前面多出来的部分，即减去从 $1$ 加到 $k-1$。下图以求 $4$ 到 $9$ 加和举例：

![](http://pic.caiwen.work/i/2025/07/02/686490299abcd.png)

于是我们有：

$$
\sum_{i=k}^n i=\sum_{i=1}^{n} i - \sum_{i=1}^{k-1} i
$$

等号右边的两部分直接套从 $1$ 加到 $n$ 的那个公式即可。

实际上，从 $1$ 到 $n$ 这 $n$ 个数字构成了一个**数列**。并且还是一个**等差数列**，因为前后两个数字之间之差为 $1$，我们将其称为**公差**。等差数列不止这一种，比如 $4,7,10,...$，从 $4$ 开始，公差为 $3$。所有的等差数列都可以通过上述的方法得到，就比如 $4,7,10,...,n$ 这种，我们还是把这个数列正着写一遍再反着写一遍，有：

$$
\begin{aligned}
&4&,&7&,&10&,&...&,&n-6&,&n-3&,&n \\
&n&,&n-3&,&n-6&,&...&,&10&,&7&,&4
\end{aligned}
$$

我们发现上下两个数相加都为 $n+4$。易知每行一共是有 $\frac{n-4}{3}+1$ 个数字，所以得到最终的求和公式为：

$$
\frac{(n+4)(n-4)+3(n+4)}{6}
$$

## 2 时间复杂度分析

我们先通过一道题目来举例：

**调和级数部分和**

**【例6.1】调和级数部分和** https://hydro.ac/d/czsc/p/P1023

首先我们可以飞快写出一个朴素做法：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
void subtask(){
	int n;
    cin>>n;
	double ans=0;
	for(int i=1;i<=n;i++){
		ans+=1.0/i;
	}
	printf("%.10lf\n",ans);
}
signed main(){
	int t;
	cin>>t;
	while(t--){
		subtask();
	}
	return 0; 
} 
```

这里借机补充一点东西：

这道题是一种多测题，就是在一个测试点中又塞了多组测试数据。一般我们为了代码的好看，会在 main 函数里去读入 $T$，然后创建一个 subtask 函数来处理每一组数据。这里有一个小技巧， `while(t--)` 可以刚好让 `while` 循环执行 `t` 次，具体的原因我们这里不说，同学们可以自行去了解。当然你也可以写 `for(int i=1;i<=t;i++)`。

我们调用 printf 函数，函数的第一个参数是 `"%.10lf\n"`。其中 `%.10lf` 就表示保留 10 位小数输出，我们已经讲过。后面又有一个 `\n`，这个就表示一个换行符，和 `cout<<endl;` 是一个效果。

然后我们提交，发现并没有获得满分，有几个测试点 TLE 了，我们的程序在数据量较大的情况下无法在给定时间限制，即 1s 内给出答案。

如何判断我们的代码会不会在最大数据量的情况下超时？一个简单的想法是手动造出一个很大的数据然后在自己电脑上运行一下试试。但这个想法有一些局限性：一个是我们可能很难造出一个强度很大的数据（当然本地的数据其实不难造），而且造数据也是有点麻烦的；同时，电脑之间的性能也不一样，一般评测网站上使用的电脑的性能是比较强的，但我们自己的电脑可能比较旧，同样的数据在自己电脑上可能要跑 7s 甚至 8s，但是在评测网站上 1s 就跑完了。

我们希望能够直接根据代码来从理论上评估这个代码的运行效率。在计算机科学中，我们使用一个叫**时间复杂度**的东西来评估程序的运行效率。

我们假设代码中每一个语句运行都需要消耗一定的时间，并且跳过声明类型的语句、代码最开头的 `#` 开头的语句、`using namespace std;` 等，只关注最核心的代码，就有：

```cpp linenums="1"
#include<bits/stdc++.h>
#define int long long
using namespace std;
void subtask(){
	int n;
    cin>>n; // c3
	double ans=0;
	for(int i=1;i<=n;i++){ // c4
		ans+=1.0/i; // c5
	}
	printf("%.10lf\n",ans); // c6
}
signed main(){
	int t;
	cin>>t; // c1
	while(t--){ // c2
		subtask(); 
	}
	return 0; 
} 
```

我们把一行代码执行一次消耗的时间记为 `c1`、`c2`、......、`c6`，并标在了后面的注释中来方便展示。然后我们简单计算一下整个程序的运行时间

* 首先是一个 $c_1$ 的时间输入 $T$
* 然后是 $T$ 次循环，但是第 16 行的代码其实是执行了 $T+1$ 次（因为最后多出来一次执行，再次判断循环条件是否满足，不满足就跳出去）。这里总耗时 $c_2(T+1)$
* 我们姑且认为函数的调用是不耗时的（其实是耗时的，但对于我们总体的分析影响不大）
* 然后看向第 6 行，$c_3$ 的时间输入 $n$
* 然后第 8 行的循环会循环 $n$ 次，总耗时 $c_4(n+1)$
* 第 9 行的代码在循环内部，总共执行 $n$ 次，总耗时 $c_5n$
* 然后第 11 行 $c_6$ 的时间输出答案
* 我们后面从第 6 行到第 11 行分析得到的耗时，是一个 subtask 函数的耗时，而我们会执行 $T$ 次 subtask 函数

于是整个程序的总耗时为：

$$
c_1+c_2(T+1)+T(c_3+c_4(n+1)+c_5n+c_6)
$$

整理一下：

$$
(c_4+c_5)Tn+(c_2+c_3+c_4+c_6)T+c_1+c_2
$$

就得到了一个程序运行需要的时间。其中 $c_i$ 都是一个常数，而 $T$ 和 $n$ 相当于是自变量，运行时间相当于是因变量，由此构成了一个函数。我们现在考虑函数对这个函数进行化简，我们只关注函数的增长率或者是增长量级：

* 首先把常数项去掉，因为常数项不影响一个函数的增长速度
* 然后把所有的系数都去掉，或者说是变为 $1$，因为系数其实也不影响函数的增长速度（注意是增长速度，考虑增长速度时不考虑函数谁大谁小）

于是得到：

$$
Tn+T
$$

* 我们只保留 $Tn$，因为 $Tn$ 随着 $T$ 和 $n$ 的增加，增长的速度快于 $T$。你也可以把 $T$ 视为 $n$，$n^2$ 增长的比 $n$ 快。

最终，我们再用一个符号 $O$ 去包裹最终化简的函数，即最终写成 $O(Tn)$。这个东西就叫做上面这个代码的时间复杂度。我们得到的时间复杂度最好是仅涉及题目数据范围中出现的变量。

当然，上面是很理性地去分析时间复杂度。我们回顾一下上述的分析过程，能在最后产生一个系数乘上 $T$ 或者是 $Tn$ 这种与数据范围有关的项，基本上都是由于循环。所以我们后续分析一个代码的时间复杂度的时候，没必要像上面那样很麻烦地去分析，我们直接看循环：上面 main 函数中会有一个循环 $T$ 次的 `while` 循环，而 `while` 循环每次调用的 subtask 中又有一个循环 $n$ 次的 `for` 循环。那么总循环次数大概就是 $Tn$，所以时间复杂度就是 $O(Tn)$。这样分析很粗略，但是你考虑我们上面得到时间复杂度的时候也是大力化简，所以其实没什么问题。

有了时间复杂度，我们就能去分析一个程序的运行时间了。我们把题目中最大的数据范围代入这个时间复杂度的式子，比如本题数据范围最大时 $T=n=10^5$，$Tn=10^{10}$。也就是我们的代码在数据范围最大的时候大概要执行 $10^{10}$ 次代码语句。而现代的计算机一般在 1s 之内最多只能执行 $10^8$ 次代码语句。那么我们的程序必然是超时了，而且跑完最大的数据，大概需要 100s ！

## 3 预处理

和上一节一样，我们介绍一个能够解决 TLE 的方法：预处理。预处理就是我们预先去处理出一些数据，后面需要的时候直接使用，而不用去反复生成数据，从而节省时间。

对于上面这个题，我们的大多数的时间都浪费在反复求 $1+\frac{1}{2}+\frac{1}{3}+...+\frac{1}{n}$。我们能不能先把所有的部分和都求出来放到一个数组里，然后后面要输出答案的时候直接访问数组就好了，我们试试：

```cpp linenums="1"
#include<bits/stdc++.h>
#define int long long
using namespace std;
double ans[100005];
signed main(){
	for(int i=1;i<=100000;i++){
		for(int j=1;j<=i;j++){
			ans[i]+=1.0/j;
		}
	}
	int t;
	cin>>t;
	while(t--){
		int n;
		cin>>n;
		printf("%.10lf\n",ans[n]);
	}
	return 0; 
} 
```

上述代码在第 6 到第 10 行提前把所有可能要求的部分和全部求出来保存到了数组中。后面我们的 `while` 循环就可以直接输出答案，非常快速。其中第 6 到第 10 行代码就相当于做了一个**预处理**。

但是你发现我们运行这个代码之后，迟迟不能输入数字，好像程序卡死了。这是因为我们的代码卡在了预处理部分。我们分析一下预处理部分的时间复杂度，两层循环，外层循环循环 $10^5$ 次，而内层循环循环 $i$ 次。我们发现这时候有点不对劲，我们发现内层循环的循环次数是依赖于外层循环的。其实我们可以这么考虑，第 8 行会先执行 $1$ 次（$i=1$ 时），再执行 $2$ 次（$i=2$ 时），....，一直到执行 $n$ 次。那么总执行次数就是 $1+2+3...+n$，根据本节最开始讲到的内容，第 8 行代码总执行次数为：

$$
\frac{n(n+1)}{2}=\frac{1}{2}n^2+\frac{1}{2}n
$$

保留增长最大的部分（也就是次数最大的部分），去掉常系数，我们就得到上述预处理部分的时间复杂度为 $O(n^2)$，这里 $n$ 取 $10^5$，得到总运行代码语句次数为 $10^{10}$。我们通过时间复杂度分析，发现这么做比最开始的朴素做法强不到哪里去。

但是你注意，这个部分和其实是有一个递推关系，也就是 $S(n)=S(n-1)+\frac{1}{n}$，我们求 $S(n)$ 时可以直接在前面那个 $S(n-1)$ 的基础上去求，而不用从头开始求：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
double ans[100005];
signed main(){
	for(int i=1;i<=100000;i++){
		ans[i]=ans[i-1]+1.0/i;
	}
	int t;
	cin>>t;
	while(t--){
		int n;
		cin>>n;
		printf("%.10lf\n",ans[n]);
	}
	return 0; 
} 
```

那么我们现在分析一下时间复杂度，首先是一个 $10^5$ 次的循环，我们姑且将其看成循环 $n$ 次吧（反正我们最后也是让 $n$ 取 $10^5$），然后后面是一个循环了 $T$ 次的 `while` 循环。那么时间复杂度就为 $O(T+n)$，如果我们视 $n$ 和 $T$ 差不多大，那么时间复杂度就是 $O(2T)$ 即 $O(T)$。$T$ 最大为 $10^5$，会发现总代码执行次数小于 $10^8$，理论上我们的代码可以通过本题。提交之后也确实如此。

那么我们就得到了一种减小时间复杂度的做法：预处理。但是也需要注意，预处理本身的时间复杂度不能太高。

## 4 前缀和算法

### 4.1 基础

上面的预处理不能算是什么算法，只能说是一种“手法”。下面我们以一道题目举例，来学习我们第一个算法：前缀和算法。

**【例6.2】区间加问题（加强版）** https://hydro.ac/d/czsc/p/P1024

我们能很快给出一个朴素的做法：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int mod=1000000007;
int a[1000006];
signed main(){
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=m;i++){
		int l,r;
		cin>>l>>r;
		int sum=0;
		for(int j=l;j<=r;j++){
			sum=(sum+a[j])%mod;
		}
		cout<<sum<<endl;
	}
	return 0; 
} 
```

好，提交上去，不出意外又得了 0 分，全部 TLE。

我们分析一下时间复杂度，首先是循环 $n$ 次读入数据，然后循环 $m$ 次处理询问，处理每个询问要从 $l$ 循环到 $r$，一共是循环 $r-l+1$ 次。我们分析时间复杂度的时候一般是要分析最坏情况，本题最坏情况就是，每次询问都询问区间 $[1,n]$ ，这样循环 $r-l+1$ 次就变成了循环 $n$ 次。那么时间复杂度就是 $O(n+mn)$，取最高次，即 $O(mn)$。我们还是不妨假设 $n$ 和 $m$ 大小差不多，就变成了 $O(n^2)$ 的时间复杂度。带入最大数据范围，得到了 $10^{12}$，远远大于 $10^8$。

我们考虑怎么去解决。假如每次询问的 $l$ 都为 $1$ 的话，其实不难做，我们根据上一题，使用预处理的方法，先预处理出 $sum_n$ 表示 $\sum_{i=1}^n$。然后询问的时候直接就以相当于是 $O(1)$ 的时间复杂度回答询问就可以了（$O(1)$ 也就相当于是不再嵌套循环了）。预处理的时候仍要注意到 $sum_n=sum_{n-1}+a_n$，基于前一个 $sum_{n-1}$ 求当前的 $sum_n$ 会降低时间复杂度。那么总时间复杂度就是 $O(n+m)$ 或者说是 $O(n)$ 的。我们把从 $a_1$ 一直加到 $a_n$ ，即 $sum_n$ 称为**前缀和**，从第一项开始加，加和的部分是整个数列的前缀。

但是现在 $l$ 可能不为 $1$，那该怎么办？你还记得我们怎么求从 $k$ 一直加到 $n$ 的吗？我们有：

$$
\sum_{i=l}^r a_i=\sum_{i=1}^{r}-\sum_{i=1}^{l-1}=sum_{r}-sum{l-1}
$$

也就是，如果询问中间某段区间的和，我们可以转换为两个前缀和的差值。

![](http://pic.caiwen.work/i/2025/07/02/6864926958221.png)

这就是前缀和算法。前缀和算法本质上还是一种预处理。本题应用前缀和算法之后我们可以得到：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int mod=1000000007;
int a[1000006],sum[1000006];
signed main(){
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		sum[i]=(sum[i-1]+a[i])%mod;
	}
	for(int i=1;i<=m;i++){
		int l,r;
		cin>>l>>r;
		cout<<(sum[r]-sum[l-1]+mod)%mod<<endl;
	}
	return 0; 
} 
```

强调几点，注意开 long long，注意不要少取模了，注意是 `-sum[l-1]` 不是 `-sum[l]`。

不过提交之后，还是有一个测试点 TLE 了，明明我们的时间复杂度分析的是没问题的，这是什么问题？实际上，当题目的数据量到达 $10^6$ 这个量级之后，数据量就很大了，我们的代码读入数据所需要的时间无法忽略不计。本题最后一个测试点就是这样，数据量很大，我们读入数据耗时很多，导致了最终 TLE。为了解决这一问题，我们需要提高数据读入的速度。我们可以在 main 函数的开头加上 `ios::sync_with_stdio(false);` 这行代码来加速数据读入。具体原理我们不讲，感兴趣的同学可以自行学习。

```cpp linenums="1" hl_lines="7"
#include<bits/stdc++.h>
#define int long long
using namespace std;
int mod=1000000007;
int a[1000006],sum[1000006];
signed main(){
	ios::sync_with_stdio(false); 
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		sum[i]=(sum[i-1]+a[i])%mod;
	}
	for(int i=1;i<=m;i++){
		int l,r;
		cin>>l>>r;
		cout<<(sum[r]-sum[l-1]+mod)%mod<<endl;
	}
	return 0; 
} 
```

### 4.2 变形

前缀和算法不一定要“前缀”。比如，我现在想要快速的去求从 $a_i$ 一直加到 $a_n$ 的和，我们可以预处理出一个“后缀”和 $pre_i=\sum_{j=i}^n a_j$，然后就可以很快速的去求了。

前缀和算法也不一定要“和”。比如，我们要求一个区间所有的数字的乘积，我们把前缀和算法的加法改成乘法就可以了。

当然，一个比较常用的手法是：前缀最大值/最小值、后缀最大值/最小值。我们拿一道题目举例：

**【例6.3】最大子段和** https://hydro.ac/d/czsc/p/P1025

首先我们仍能给出一个非常朴素的做法：我们枚举区间的左端点还有区间的右端点，然后求出区间和，然后和当前的最大值取个 max：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[200005];
signed main(){
	ios::sync_with_stdio(false); 
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	int ans=-0x3f3f3f3f3f3f3f3f;
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			int sum=0;
			for(int k=i;k<=j;k++){
				sum+=a[k];
			}
			ans=max(ans,sum);
		}
	}
	cout<<ans;
	return 0; 
} 
```

注意我们这里有一个技巧：`ans` 的初始值为 `-0x3f3f3f3f3f3f3f3f`。由于我们是想不断地和 `ans` 取 max，那么 `ans` 的初始值应该是一个非常小的数字，这样才可以保证求出的第一个 `sum` 一定可以更新掉 `ans`。在数学中我们可以用 $-\infty$ 来表示一个极小的数字，但是在 C++ 中没有这个说法，我们只能手动给出一个很小的值来达到类似效果。`0x3f3f3f3f3f3f3f3f` 就是一个很大的数字，他的负数就是一个很小的数字。注意，如果是 long long 类型，我们就赋值为 `0x3f3f3f3f3f3f3f3f`（同时你要注意，尽管我这里写的是 `int`，但我前面还写了 `#define int long long`，所以这里其实是 `long long`），而如果是 int 类型，那么我们应该赋值成 `0x3f3f3f3f`（前者是 $8$ 个 `3f`，后者是 $4$ 个 `3f`）。

分析一下上述代码的时间复杂度，首先是一个 $n$ 次循环读入数据，然后是一个 $n$ 次的关于 `i` 的循环。这个循环内部又有一个关于 `j` 的循环，循环次数准确地来说是 $n-i+1$ 次，但我们考虑最坏情况，就是 $n$ 次，在其内部又有一个关于 `k` 的循环，循环次数最坏是 $n$ 次。综上，总的时间复杂度应该是 $O(n^3+n)$，由于三次项的存在，我们忽略掉一次项，最终时间复杂度为 $O(n^3)$。将 $n=2\times 10^5$ 带入，会发现结果远远大于 $10^8$，必然超时。

考虑优化。我们发现关于 `k` 的那个循环可以优化掉，因为这个求区间和可以直接用前缀和算法。应用前缀和算法后：

```cpp linenums="1" hl_lines="12-14"
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[200005],sum[200005];
signed main(){
	ios::sync_with_stdio(false); 
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		sum[i]=sum[i-1]+a[i];
	}
	int ans=-0x3f3f3f3f3f3f3f3f;
	for(int i=1+1;i<=n;i++){
		for(int j=i;j<=n;j++){
			ans=max(ans,sum[j]-sum[i-1]);
		}
	}
	cout<<ans;
	return 0; 
} 
```

分析一下时间复杂度，为 $O(n^2)$，还是太慢了。

然后我们考虑一下，做完前缀和之后，原题就被我们转化为：寻找 $i$ 和 $j$，满足 $0\le i\le j\le n$ ，使得 $sum_j-sum_i$ 最大。这其实也是一个经典手法：遇到区间和问题应首先考虑转化为前缀和。然后我们考虑，假如我们现在固定住 $i$，也就是 $sum_i$ 确定了，那么想让 $sum_j-sum_i$ 最大就需要让 $sum_j$ 最大。也就是现在我们的问题就变成了如何快速地在区间 $[i,n]$ 中找到一个 $j$ 使得 $sum_j$ 最大。这时候我们就可以用上前缀和的一个变形：后缀最大值了。我们预处理出 $suf_i$ 为 $[i,n]$ 这个后缀区间中最大的那个 $sum$ 值。预处理之后再去使用就快速很多了：

```cpp linenums="1" hl_lines="15-18"
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[200005],sum[200005],suf[200005];
signed main(){
	ios::sync_with_stdio(false); 
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		sum[i]=sum[i-1]+a[i];
	} 
	suf[n]=sum[n];
	for(int i=n-1;i>=1;i--){
		suf[i]=max(suf[i+1],sum[i]);
	}
	int ans=-0x3f3f3f3f3f3f3f3f;
	for(int i=0;i<n;i++){
		ans=max(ans,suf[i+1]-sum[i]);
	}
	cout<<ans;
	return 0; 
} 
```

## 5 差分算法

还是拿一道题目来引入：

**【例6.4】区间加，单点询问** https://hydro.ac/d/czsc/p/P1004

我们还是可以飞快的写出一个朴素的做法：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[500005]; 
signed main(){
	ios::sync_with_stdio(false); 
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=m;i++){
		int op;
		cin>>op;
		if(op==1){
			int l,r,k;
			cin>>l>>r>>k;
			for(int j=l;j<=r;j++){
				a[j]+=k;
			}
		}else{
			int x;
			cin>>x;
			cout<<a[x]<<endl;
		}
	}
	return 0; 
} 
```

提交之后，不出意外，又 TLE ，获得 0 分。上述代码的时间复杂度为 $O(nm)$ 或者说是 $O(n^2)$ 的（分析过程和上面讲前缀和的时候的分析过程类似，这里不再赘述），而 $n,m$ 最大为 $5\times 10^5$，必然是会超时的。

在考虑如何优化上述代码之前我们先讲差分算法。我们首先介绍一下什么是差分数列。给出 $n$ 个数字，他们构成了一个数列。然后，我们让每个数字都减去前面的数字，特别地，我们认为第一个数字前面的数字是 $0$。这样相减就能得到 $n$ 个新的数字，这些数字构成了一个新数列。我们把这个新数列称为原数列的差分数列。

![](http://pic.caiwen.work/i/2025/07/04/6867cf4a3ac68.png)

然后我们可以对这个差分数列做一个前缀和，发现做完前缀和之后又把原来的数列给还原了。差分和前缀和之间是有联系的。

![](http://pic.caiwen.work/i/2025/07/04/6867d00e5f3f8.png)

更形式地讲，我们有一个 $n$ 个元素的数列 $a_i$，其差分数列中 $d_i=a_i-a_{i-1}$，特别地，令 $a_0=0$。那么就有 $a_i=\sum_{j=1}^i d_i$。

我们得到差分数列有什么用呢？用处在于。我们可以把对于原数列的区间加操作转化为对于差分数列的单点加操作。

比如，我们现在把差分数列的某一项加上 $2$，然后再做前缀和：

![](http://pic.caiwen.work/i/2025/07/04/6867d115b6073.png)

我们发现，和原数列相比，加上 $2$ 的这个位置之前的各项没有发生改变，而之后的各项都增加了 $2$。你看，这就相当于是给后面的这一个区间整个都加上了 $2$。从感性上理解，在差分数列上某一项加 $2$ 后，其产生的影响将会随着前缀和而传播到后面。

那么现在假设我要给原数列的区间 $[l,n]$ 都加上 $x$，那么只需要给 $d_l$ 加上 $x$ 就好了。但是如果要是给区间 $[l,r]$ 都加上 $x$ 呢？我们先给 $d_l$ 加 $x$，此时区间 $[l,n]$ 都加上 $x$ 了，但我们希望 $[r+1,n]$ 不变，而这一块多加了 $x$，我们需要把他减掉，于是我们再把 $d_{r+1}$ 减去 $x$，此时 $[r+1,n]$ 这一部分又把之前多加的给减去了，又恢复了原状。

那么我们可以表述为，要给原数列的区间 $[l,r]$ 加上 $x$，只需要把差分数列的第 $l$ 项加上 $x$，第 $r+1$ 项减去 $x$。这就是差分算法。

我们再从时间复杂度的角度来看待这个事，会发现朴素的做法和差分算法是两个极端：

* 对于朴素的做法，我们可以直接 $O(1)$ 求出某个位置上的数字（直接数组下标访问），而需要 $O(n)$ 的时间进行区间加操作（开循环）
* 对于差分算法，我们求出某个位置上的数字就需要 $O(n)$ 的时间了（需要开循环，对差分数列做前缀和才能还原）,而只需要 $O(1)$ 的时间进行区间加操作（只需要在差分数列的两个位置进行修改）

那么回过头来我们看这道题，这道题前面都是区间加操作，我们走一个差分序列，就可以做到每个操作都能 $O(1)$ 解决。而后面都是询问，如果我们每个询问都做一遍前缀和，那么单次询问时间复杂度就是 $O(n)$，总时间复杂度就是 $O(nm)$，还是不行。但是我们还可以有一种预处理的思想，全部修改操作完成之后，我们直接把差分数列还原，保存到一个数组中，那么后续的询问都可以 $O(1)$ 去回答了。此时题目中看似奇怪的条件：保证所有操作 $2$ 都在操作 $1$ 之后，也体现出作用。这样可以保证，我们把差分数列还原之后就不会再有任何改动了，否则的话，如果操作 $2$ 后面还有操作 $1$，那么我们就不得不再次对差分序列求前缀和，复杂度又升到了 $O(nm)$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[500005],d[500005]; 
signed main(){
	ios::sync_with_stdio(false); 
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		d[i]=a[i]-a[i-1];
	}
	bool flag=false; // 是否将差分数列还原 
	for(int i=1;i<=m;i++){
		int op;
		cin>>op;
		if(op==1){
			int l,r,k;
			cin>>l>>r>>k;
			d[l]+=k,d[r+1]-=k;
		}else{
			if(!flag){
				// 虽然这里又出现了嵌套循环，但你注意，这里的循环只会被执行一次，分析出来的时间复杂度不是 O(nm) 
				for(int i=1;i<=n;i++){
					a[i]=a[i-1]+d[i];
				}
				flag=true;
			}
			int x;
			cin>>x;
			cout<<a[x]<<endl;
		}
	}
	return 0; 
} 
```

## 6 总结

* 等差数列求和
    * 倒序相加
    * 类似前缀和思想的区间求和
* 语法补充
    * 多测，`while(t--)`
    * `printf` 中的 `\n`
    * `ios::sync_with_stdio(false);` 加速读入
    * `0x3f3f3f3f3f3f3f3f` 和 `0x3f3f3f3f` 表示无穷
* 时间复杂度分析
    * 关注循环
    * 消常数项，系数变为 $1$，看最高次项
* 预处理
    * 前缀和算法
        * 后缀
        * 前缀/后缀积，前缀/后缀最大值
    * 差分算法

## 7 作业

请再次独立做一遍本节的例题：

* **【例6.1】调和级数部分和** https://hydro.ac/d/czsc/p/P1023
* **【例6.2】区间加问题（加强版）** https://hydro.ac/d/czsc/p/P1024
* **【例6.3】最大子段和** https://hydro.ac/d/czsc/p/P1025
* **【例6.4】区间加，单点询问** https://hydro.ac/d/czsc/p/P1004

作业题目：

值得注意的是，从算法部分开始，题目可能会稍微有一点难度，如果你哪里遇到了困难欢迎进行提问。

* **【作业6.1】光骓者的荣耀** https://hydro.ac/d/czsc/p/P1026