# 七 排序算法

## 1 朴素的排序

现在给你 $n$ 个数，要求你把这 $n$ 个数按照从小到大的顺序进行排序，你如何用代码实现？实现起来并不复杂，有很多种做法。比如我有一个做法：不断地找 $n$ 个数中未被标记的数字的最小值，找到最小值之后就将这个最小值标记，并放入到另一个数组的末尾。代码写起来大概是这样的：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[200005],tag[200005],b[200005];
// a 为原数组 
// tag[i] 表示 a[i] 是否被标记了 
// b 为排好序的数组 
signed main(){
    ios::sync_with_stdio(false); 
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
	int ok=0;//排好序的数字数量 
    while(ok!=n){
    	int t=0x3f3f3f3f3f3f3f3f;
    	int p=-1;
    	for(int i=1;i<=n;i++){
    		if(tag[i]==1){
    			continue;
			}
			if(a[i]<t){
				t=a[i];
				p=i;
			}
		}
		tag[p]=1;
		ok++;
		b[ok]=t;
	} 
	for(int i=1;i<=n;i++){
		cout<<b[i]<<' ';
	}
    return 0; 
} 
```

简单分析一下时间复杂度，大概是 $O(n^2)$ 的，也就是说 $n$ 最大差不多取到 $10^3$ 才可以让上面这个代码在 1s 内求出结果。

## 2 冒泡排序

冒泡排序是一个经常被人提起的算法。他的大概思路就是，从左到右去扫面这个序列，相邻的数字两两比较，如果左边的数字比右边的数字大，那么就交换这两个数字。大概扫描 $n$ 次，这个序列就一定会被排好序。比如对于 `4 3 2 5 1`，我们有如下过程：

第一次扫描：

![](http://pic.caiwen.work/i/2025/07/04/6867f346a2cec.png)

我们观察一下数字 $4$ 的轨迹，会发现这个比较大的数字在扫描过程中会一直被“往后抛”。那么从感性上理解，大的数字会在一次又一次的扫描中不断被抛到后面，而小的数字则会随之到数列的前面，直到数列已经被排好序，此时相邻数字都满足左边比右边小，不会发生交换。比较大的数字像是气泡一样不断往右边的水面行进，“冒泡”排序由此得名。

![](http://pic.caiwen.work/i/2025/07/04/6867f512b228a.png)

![](http://pic.caiwen.work/i/2025/07/04/6867f51eb3a91.png)

数列在第 $n$ 次扫描中间就已经排好序了，所以后续必然不会再有交换行为，所以后面就不再继续往下画了。

写成代码的话大概就是这样：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[200005],tag[200005],b[200005];
// a 为原数组 
// tag[i] 表示 a[i] 是否被标记了 
// b 为排好序的数组 
signed main(){
    ios::sync_with_stdio(false); 
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
	for(int i=1;i<=n;i++){ // n 次扫描 
		for(int j=1;j<n;j++){ // j和j+1比较，所以这里 j 不要到 n 
			if(a[j]>a[j+1]){
				swap(a[j],a[j+1]);
			} 
		}
	}
	for(int i=1;i<=n;i++){
		cout<<a[i]<<' ';
	}
    return 0; 
} 
```

然后我们分析一下时间复杂度，还是 $O(n^2)$ 的。这个看起来比较智慧的算法和我们上面那个朴素的算法其实强不到哪里去。不过我们最好还是对这个算法有印象，因为这个算法相对来说比上面朴素的算法好写，而且后面可能会有题目以冒泡排序作为题目背景。

## 3 归并排序

那么我们能不能有更快的排序算法呢？有。我们先考虑这样一个问题：给你两个数列 $a_i$ 和 $b_i$，$a_i,b_i$ 都是从小到大排好序的。现在请让你合并 $a_i$ 和 $b_i$ 得到一个也排好序的 $c_i$。当然我们可以直接把 $a_i,b_i$ 首位相接然后跑一个冒泡排序算法，时间复杂度是 $O(n^2)$ 的。但是我们还可以更快一点：考虑到两个数列都已经分别排好序，我们可以整两个指针，分别指向数列的首位，然后每次将两个指针中指向的数字最小的那个取出来放入数列 $c_i$ 中，然后该指针向后移动。

![](http://pic.caiwen.work/i/2025/07/05/68688a1c3c098.png)

![](http://pic.caiwen.work/i/2025/07/05/68688a380f3d1.png)

然后我们考虑一种“分治”思想。实际上我们后续会学分治算法，但由于时间关系我们本次课程不去专门讲解分支算法。我们只是在这里简单说一下。分治的思想可以概括为：将一个大问题拆分为多个小问题，然后逐个解决。我们把这个分治思想应用到排序，我们想要把一个数列排序，可以考虑把这个数列分成两半，然后把这两部分分别进行排序，然后再合并成原来的数列（方法就是我们上面说的这个）：

把这个大数列不断分成两半：

![](http://pic.caiwen.work/i/2025/07/05/68688bc94405d.png)

分到最后，一个小区间只剩一个数字，单个数字肯定是排好序的，然后就从下到上进行合并：

![](http://pic.caiwen.work/i/2025/07/05/68688d0ec9552.png)

然后我们考虑一下时间复杂度，首先这个算法会把数列不断分成两半，从图上来看就是分成了很多层，层数大概是 $log_2n$，然后每层中，都需要一个 $O(n)$ 的时间复杂度将两个已经排好序的子数列合并成一个大数列。

![](http://pic.caiwen.work/i/2025/07/05/68688e7859080.png)

总的时间复杂度就是 $O(nlog_2n)$。我们一般不考虑对数的底数，将其忽略，所以最后写成 $O(nlogn)$。我们都知道，对数的增长速度是远小于一次函数的：

![](http://pic.caiwen.work/i/2025/07/05/68688f10088ec.png)

所以这个时间复杂度是非常小的。我们把 $n=10^5$ 带入，$nlogn=40453037.61172421$ 小于 $10^8$，可知这种算法可以轻松处理 $n=10^5$ 量级的数据，非常快了。

这个算法的名称叫做归并排序，我们这里不讲具体的代码实现，感兴趣的同学可以自行搜索相关的代码实现。

## 4 桶排序

那么还有没有更快的排序算法呢？其实也还有，我们直接给出代码：

```cpp linenums="1"
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[200005],bu[200005];
signed main(){
    ios::sync_with_stdio(false); 
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
	for(int i=1;i<=n;i++){
		bu[a[i]]++;
	}
	for(int i=1;i<=200000;i++){
		for(int j=1;j<=bu[i];j++){
			cout<<i<<' ';
		}
	}
    return 0; 
} 
```

我们先说上面这个代码怎么达成排序大的效果的。其中一个关键的代码就是 `bu[a[i]]++;`。这个 `bu` 数组的用法很有讲究，我们之前数组的下标一般是用来表示数组的第几个元素的，可以理解为是定义域。而这里我们是把另一个数列的数字本身作为数组的下标，可以理解为是值域。`bu[x]` 并不是表示数组中第 $x$ 个数字，而是表示数字 `x` 的出现次数。那么 `bu[a[i]]++;` 的目的就是更新数字出现的次数。后面的 `for(int i=1;i<=200000;i++)` 就相当于在值域上枚举，输出 `bu[i]` 次 `i`。由于我们在值域上是从小到大枚举的，所以输出的内容必然是排好序的。这就是桶排序算法。

分析一下时间复杂度，尽管第 15 到 19 行是一个嵌套循环，外层循环循环了 $2\times 10^5$ 次，但内层只循环 `bu[i]` 次，所有的 `bu[i]` 加和一共就等于 $n$。所以时间复杂度为 $O(n)$，非常低的时间复杂度了。

但是这个算法有点缺点，那就是我们占用的内存空间会和要排序的数字的值域大小成正比。如果要排序的数字非常大，那么占用的空间也会很大。所以桶排序只适用于数字都比较小的情况。

## 5 sort 函数

### 5.1 基础用法

实际上上面讲那么多，我们只需要理解冒泡排序、归并排序、桶排序的大体思想。后面我们真正需要排序的时候直接使用 `sort` 函数就可以了。`sort` 函数是 C++ 中自带的一个函数，并且 `sort` 函数还会自动根据要排序的数列选用最合适的算法，并且对算法进行大力的优化。总之，使用 `sort` 一定能做到以最快的速度将数字排好序，我们后面需要排序的时候就不要自己手写排序算法了，直接 `sort` 即可。

`sort` 函数的时间复杂度为 $O(nlogn)$。我们后面在分析包含 `sort` 函数的代码的时间复杂度的时候不要忽略了这一点。

`sort` 函数一般接收两个函数：待排序的数组的开头和待排序的数组的结尾，且默认是从小到大排序的。如：

```cpp
int a[200005];
sort(a+1,a+n+1); // 将 a[1] 到 a[n] 从小到大排序
sort(a+l,a+r+1); // 将 a[l] 到 a[r] 从小到大排序
sort(a,a+n); // 将 a[0] 到 a[n-1] 从小到大排序
```

注意第二个参数是你要排序的区间的右边界的下一个位置。

### 5.2 自定义排序函数

不过我们想要从大到小排序该怎么办？实际上 `sort` 的函数还可以传入第三个参数。第三个参数传入的是一个函数，这个函数接受两个参数，参数的类型和要排序的元素的类型一致，然后返回一个 bool 类型：

```cpp
bool cmp(int a,int b){
    if(a>=b){
        return true;
    }else{
        return false;
    }
}
sort(a+1,a+n+1,cmp);
```

`sort` 进行排序的时候，会反复调用 `cmp` 函数，每次调用都相当于是在询问：把 `a` 放在 `b` 前面可不可以，可以的话就返回 `true`。上述代码中，我们只有 $a\ge b$ 即 $a$ 比 $b$ 大的时候才会返回 `true`，这样一来 `sort` 函数就会从大到小进行排序。传入的第三个参数即这个 `cmp` 函数就称为自定义排序函数。

### 5.3 多关键字排序

**【例7.1】生日** https://hydro.ac/d/czsc/p/P1027

观察题目，我们发现姓名，生日年月日这四个信息应该是作为一个整体的，然后再去对这个整体排序。提到若干个数据作为整体，那么我们就要想到使用结构体：

```cpp
struct S{
    string name; // 姓名
    int y,m,d; // 年月日
    int index; // 是第几个输入的
};
```

我们记录 `index` 是因为题目中说到：如果有两个同学生日相同，输入靠后的同学先输出。

按照年龄从大到小的顺序排序，其实就是按出生日期从远到近排序。比较出生日期的话我们需要先比较年份，年份小的出生日期远，如果年份相同再去比较月，如果月相同再去比较日，如果日相同那么就去比较 `index`，即输入的前后顺序。我们把排序的依据叫做排序的关键字，本题排序的关键字有四个，第一关键字是年份，第二关键字是月份，第三关键字是日，第四关键字是输入的顺序。

这种多关键字排序，首先需要使用结构体来把多个数据封装到一起，然后还需要使用自定义排序函数：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct S{
    string name; // 姓名
    int y,m,d; // 年月日
    int index; // 是第几个输入的
};
S in[101];
bool cmp(S a,S b){
	if(a.y!=b.y){
		return a.y<b.y;// 只有 a.y<b.y 才是true 
	}
	if(a.m!=b.m){
		return a.m<b.m;
	} 
	if(a.d!=b.d){
		return a.d<b.d;
	}
	// 到这里说明年月日都相同了
	return a.index>b.index; 
}
signed main(){
    ios::sync_with_stdio(false); 
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>in[i].name;
        cin>>in[i].y>>in[i].m>>in[i].d;
        in[i].index=i;
    }
	sort(in+1,in+n+1,cmp);
	for(int i=1;i<=n;i++){
		cout<<in[i].name<<endl;
	}
    return 0; 
} 
```

### 5.4 字典序

我们上面讨论的都是数字之间进行排序。实际上，字符串也能进行排序，排序的依据是字典序。字典序是这么说的，首先把两个字符串的每个字符转为其对应的 ascii 码，其中较短的字符串的末尾补 0 来与较长字符串的末尾对齐。然后我们依次比较第一个字符的 ascii 码的大小，小的那个字符串字典序就小。如果相同的话就接着比较第二个 ascii 码，以此类推...

比如：`apple` 和 `appetite`：

（图）

前三个字符对应的 ascii 码都一样，那么我们就接着比较第四个字符，`e` 对应的 ascii 码比 `l` 小，所以 `appetite` 的字典序更小，我们说 `"appetite"<"apple"`

再比如：`apple` 和 `app`：

（图）

此时就显出给较短的字符串对应的 ascii 码序列后面补 `0` 的用处来了，由于前三个字符都相同，需要比较第四个字符，但是 `app` 没有第四个字符。但 `app` 对应的 ascii 码序列后面补 0 了，我们还是能继续做比较，0 显然是最小的 ascii 码，因此我们说 `app` 的字典序更小，`"app"<"apple"`。

字典序的一个应用就是大数的比较，我们来一个例题：

**【例7.2】宇宙总统** https://hydro.ac/d/czsc/p/P1028

一眼看上去似乎很简单，就是找出 $n$ 个数字的最大值就好了，但是题目的数据范围指出，数字会很大，可能会有 100 位数字。我们目前直到能存储的最大范围数字的类型是 long long，其最大能存储 $2^31-1$，远远小于 100 位数字。实际上我们根本无法找到一个数据类型能把这 100 位数字存下来。如果我们非要存的话，只能将输入的数字视为一个字符串，看成最大长度为 100 的字符串。

然后我们考虑怎么去给两个以字符串形式存储的数字比大小。首先一点，长度小，即位数少的数字肯定是小的，所以首先我们能根据字符串的长度来判断谁打谁小。但如果两个数字的位数相同呢？回顾一下我们在数学上怎么比较两个位数相同的数字谁大谁小的，是先比较最高位，如果最高位相同再去比较次高位。然后我们发现，最高位就是对应字符串的第一个字符，次高位对应的就是第二个字符。且我们最开始讲 ascii 码的时候就说，`0` 到 `9` 这些数字的 ascii 码是连续且递增的，所以单个数字越大，他的 ascii 码也越大。结合这两点，我们就可以把相同位数的数字比大小看成数字对应的字符串的字典序比大小。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct O{
	string num;
	int index;
} in[100];
bool cmp(O a,O b){
	if(a.num.size()!=b.num.size()){
		return a.num.size()>b.num.size();
	}
	return a.num>b.num;
}
signed main(){
    ios::sync_with_stdio(false); 
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>in[i].num;
        in[i].index=i;
    }
	sort(in+1,in+n+1,cmp);
	cout<<in[1].index<<endl<<in[1].num;
    return 0; 
} 
```

## 6 总结

* 冒泡排序
* 归并排序
* 桶排序
* sort 函数
    * 基础用法
    * 自定义排序函数
    * 多关键字排序
    * 字典序
        * 根据字典序比较大数

## 7 作业

请再次独立做一遍本节的例题：

* **【例7.1】生日** https://hydro.ac/d/czsc/p/P1027
* **【例7.2】宇宙总统** https://hydro.ac/d/czsc/p/P1028

作业题目：

* **【作业7.1】奖学金** https://hydro.ac/d/czsc/p/P1029
* **【作业7.2】车厢重组** https://hydro.ac/d/czsc/p/P1030 （提示：冒泡排序）
* **【作业7.3】拼数** https://hydro.ac/d/czsc/p/P1031